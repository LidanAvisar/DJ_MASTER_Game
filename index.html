<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite Groove Game</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      canvas {
        display: block;
        cursor: none;
      }
    </style>
  </head>

  <body>
    <div
      id="splashScreen"
      style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        text-align: center;
      "
    >
      <h1
        style="
          font-family: 'Press Start 2P', Arial, sans-serif;
          font-size: 48px;
        "
      >
        DJ MASTER
      </h1>
      <button
        id="startButton"
        style="padding: 10px 20px; font-size: 20px; cursor: pointer"
      >
        Start Game
      </button>
      <p></p>
      <p
        style="
          margin-top: 20px;
          font-size: 24px;
          font-family: 'Arial', sans-serif;
          color: #00ff00;
          text-shadow: 0 0 10px #0400ff, 0 0 20px #00ff00, 0 0 30px #00ff00;
        "
      >
        In memory of the victims of the Nova Party and the events of the Seventh
        of October<br />
        let the music and be our weapon against darkness
      </p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <img
      id="altBulletImage"
      src="key_alternative.png"
      alt="Alternative Bullet"
      style="display: none"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />

    <audio id="powerUpSound" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/cheer.wav?v=1705601497573"></audio>
    <audio id="backgroundMusic" src="https://cdn.glitch.me/4a3f85be-459e-4dff-87a3-ab0925f8739a/backgroundmusic.mp3?v=1705601472807" loop></audio>
    <audio id="song1" src="https://cdn.glitch.me/4a3f85be-459e-4dff-87a3-ab0925f8739a/song1.mp3?v=1705601565916" loop></audio>
    <audio id="song2" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/song2.mp3?v=1705601576770" loop></audio>
    <audio id="song3" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/song3.mp3?v=1705601573742" loop></audio>
    <audio id="song4" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/song4.mp3?v=1705601578502" loop></audio>
    <audio id="song5" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/song5.mp3?v=1705601583015" loop></audio>
    <audio id="song6" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/song6.mp3?v=1705601587827" loop></audio>
    <audio id="song7" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/song7.mp3?v=1705601599118" loop></audio>

    <audio id="explosionSound" src="https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/explosion.wav?v=1705601538739"></audio>

    <!-- GameAnalytics -->
    <script>
      (function (w, d, a, m) {
        var s = "script";
        var g = "GameAnalytics";
        (w[g] =
          w[g] ||
          function () {
            (w[g].q = w[g].q || []).push(arguments);
          }),
          (a = d.createElement(s)),
          (m = d.getElementsByTagName(s)[0]);
        a.async = 1;
        a.src =
          "http://download.gameanalytics.com/js/GameAnalytics-4.0.9.min.js";
        m.parentNode.insertBefore(a, m);
      })(window, document);

      GameAnalytics("setEnabledInfoLog", true);
      GameAnalytics(
        "initialize",
        "52fbf487f9d85ca173d0ccbe78d708bd",
        "383d7c41e7f2b83be8e64643ca07ebed10fff0f4"
      );
    </script>
    <!-- End GameAnalytics -->
    <script>
      document
        .getElementById("startButton")
        .addEventListener("click", function () {
          document.getElementById("splashScreen").style.display = "none";
          resetGame();
        });

      const canvas = document.getElementById("gameCanvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const ctx = canvas.getContext("2d");

      const levels = 100;
      let currentLevel = 1;
      let score = 0;
      let playerHealth = 100;

      let playerX = canvas.width / 2; //he horizontal position of the player on the canvas
      let playerY = canvas.height - 30; //This is the vertical position of the player on the canvas.
      let playerWidth = 80; // size of player
      let playerHeight = 100;

      let enemies = [];
      let enemyWidth = 95;
      let enemyHeight = 100;
      let enemySpeed = 0.5;
      let enemyHorizontalSpeed = 1;

      let bullets = [];
      let bulletSpeed = 2.8;
      let bulletWidth = 40;
      let bulletHeight = 50;

      let powerUps = [];
      let powerUpWidth = 45;
      let powerUpHeight = 40;
      let powerUpSpeed = 1;
      let isPowerUpActive = false;
      let powerUpActiveTime = 9000;

      let gameInterval;
      let isGameOver = false;
      let enemyKills = 0;

      let enemyImage = new Image();
      enemyImage.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/rocket1.png?v=1705601557123";

      let playerImage = new Image();
      playerImage.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/DJ.png?v=1705601505392";

      let bulletImage = new Image();
      bulletImage.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/key.png?v=1705601551868";

      let backgroundImage = new Image();
      backgroundImage.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/back1.png?v=1705602444832";

      let bombImage = new Image();
      bombImage.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/bomb.gif?v=1705601472740";
      let bombs = [];
      const bombDisplayTime = 90;

      let powerUpImage = new Image();
      powerUpImage.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/cd.png?v=1705601484814";

      let backgroundY = 0; // Initial Y position of the background
      let targetImageSources = [""]; // Array of image sources
      let targetImages = [];
      let playAgainButtonBounds;

      let altBulletImage = new Image();
      altBulletImage.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/key_alternative.png?v=1705601546949"; // Path to your alternative bullet image
      let currentBulletImage = bulletImage;
      let charSpawnIntervalId; // Global variable to store the interval ID

      let characters = [];

      // New character properties
      let char1 = {
        image: new Image(),
        x: Math.random() * (canvas.width - 50),
        y: -50,
        width: 50,
        height: 50,
      };
      char1.image.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/char1.png?v=1705601483972";

      let char2 = {
        image: new Image(),
        x: Math.random() * (canvas.width - 50),
        y: -50,
        width: 50,
        height: 50,
      };
      char2.image.src = "https://cdn.glitch.global/4a3f85be-459e-4dff-87a3-ab0925f8739a/char2.png?v=1705601487387";

      let bulletChangeTimer = 0; // Timer for the bullet change effect
      let bulletFrequencyTimer = 0; // Timer for the bullet frequency effect
      let lastShotTime = 0;
      let shootingInterval = 500; // Normal shooting interval in milliseconds

      let char1Speed = 2.0; // Adjust this value as needed for char1
      let char2Speed = 2.0;

      let char1Cooldown = 0;
      let char2Cooldown = 0;
      let charCooldownTime = 10000;

      let lastTime = 0;

      function gameLoop(timestamp) {
        // Calculate the time difference since the last frame
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        // Update game logic and draw
        updateGameArea(deltaTime);

        // Schedule the next frame
        if (!isGameOver) {
          requestAnimationFrame(gameLoop);
        }
      }

      function loadTargetImages() {
        let loadedImages = 0;
        for (let src of targetImageSources) {
          let img = new Image();
          img.onload = function () {
            targetImages.push(img);
            loadedImages++;
            if (loadedImages === targetImageSources.length) {
              spawnTargets(); // Call spawnTargets only after all images are loaded
            }
          };
          img.onerror = function () {
            console.error("Failed to load image:", src); // Error handling
          };
          img.src = src;
        }
      }

      function spawnTargets() {
        for (let i = 0; i < targetImages.length; i++) {
          let img = targetImages[i];
        }
      }

      function drawTargets() {
        const scaleFactor = 0.3;
        for (let target of targets) {
          let scaledWidth = target.img.width * scaleFactor;
          let scaledHeight = target.img.height * scaleFactor;
          ctx.drawImage(
            target.img,
            target.x,
            target.y,
            scaledWidth,
            scaledHeight
          );
        }
      }

      function spawnEnemies() {
        // Base enemy speed
        let baseSpeed = 0.45;

        // Enemy speed increases more gradually in advanced stages
        let speedIncreaseFactor = 0.02; // Smaller increase per level
        let maxSpeedIncrease = 0.4; // Maximum additional speed

        // Calculate enemy speed based on the current level with a cap
        enemySpeed =
          baseSpeed +
          Math.min(speedIncreaseFactor * currentLevel, maxSpeedIncrease);

        // Horizontal speed of enemies remains constant
        enemyHorizontalSpeed = 1;

        // Base number of enemies starts at 3
        let baseNumberOfEnemies = 5;

        // The number of enemies increases slowly and is capped
        let enemyIncreaseFactor = 0.25; // Slower increase per level
        let maxEnemies = 12; // Cap the number of enemies

        // Calculate the number of enemies based on the current level with a cap
        let numberOfEnemies = Math.min(
          baseNumberOfEnemies + Math.floor(enemyIncreaseFactor * currentLevel),
          maxEnemies
        );

        // Spawn enemies
        for (let i = 0; i < numberOfEnemies; i++) {
          enemies.push({
            x: Math.random() * (canvas.width - enemyWidth),
            y: Math.random() * -400 - enemyHeight, // Starting off-screen
            horizontalSpeed: enemyHorizontalSpeed,
          });
          setTimeout(enemyShoot, Math.random() * (6000 - 2000) + 2000, i);
        }
      }

      function spawnCharacter(character, minInterval, maxInterval) {
        const spawn = () => {
          // Randomize the x position within the canvas width
          character.x = Math.random() * (canvas.width - character.width);
          // Set the y position to just above the top of the canvas
          character.y = -character.height;

          // Randomly decide the next spawn time within the specified range
          const nextSpawnTime =
            Math.random() * (maxInterval - minInterval) + minInterval;

          // Set the timeout for the next spawn
          setTimeout(spawn, nextSpawnTime);
        };

        // Start the first spawn
        spawn();
      }

      function drawPlayer() {
        ctx.drawImage(playerImage, playerX, playerY, playerWidth, playerHeight);
      }

      function drawEnemies() {
        enemies.forEach((enemy) => {
          ctx.drawImage(enemyImage, enemy.x, enemy.y, enemyWidth, enemyHeight);
        });
      }

      function drawBullets() {
        bullets.forEach((bullet) => {
          ctx.drawImage(
            currentBulletImage,
            bullet.x,
            bullet.y,
            bulletWidth,
            bulletHeight
          );
        });
      }

      function drawPowerUps() {
        powerUps.forEach((powerUp) => {
          ctx.drawImage(
            powerUpImage,
            powerUp.x,
            powerUp.y,
            powerUpWidth,
            powerUpHeight
          );
        });
      }

      function drawHUD() {
        ctx.fillStyle = "black";
        ctx.font = "16px 'Press Start 2P', Arial";
        ctx.fillText(`Level: ${currentLevel}`, 20, 20);
        ctx.fillText(`Score: ${score}`, 20, 40);
        ctx.fillText(`Health: ${playerHealth}`, 20, 60);
        ctx.fillText(`Kills: ${enemyKills}`, 20, 80);
      }

      function drawBomb(x, y) {
        ctx.drawImage(bombImage, x, y, enemyWidth, enemyHeight);
      }

      function enemyShoot(enemyIndex) {
        if (enemies[enemyIndex]) {
          setTimeout(
            enemyShoot,
            Math.random() * (6000 - 2000) + 2000,
            enemyIndex
          );
        }
      }

      function checkTargetCollision() {
        const scaleFactor = 0.3;
      }
      function initiateGame() {
        document.getElementById("backgroundMusic").play();
        requestAnimationFrame(gameLoop); // Add this line
      }

      function gameOver() {
        clearInterval(gameInterval); // Stop the game loop
        displayGameOver(); // Call the function to display the game over screen
        // Additional game over logic if needed
      }

      function updateGameArea() {
        // Draw the background twice to create a continuous effect
        ctx.drawImage(
          backgroundImage,
          0,
          backgroundY,
          canvas.width,
          canvas.height
        );

        drawPlayer();
        drawEnemies();
        drawBullets();
        drawPowerUps();
        drawHUD();
        checkTargetCollision();

        if (Date.now() > char1Cooldown) {
          char1.y += char1Speed; // Use char1Speed for vertical movement
          ctx.drawImage(
            char1.image,
            char1.x,
            char1.y,
            char1.width,
            char1.height
          );
        }
        // Update position and draw char2
        if (Date.now() > char2Cooldown) {
          char2.y += char2Speed; // Use char2Speed for vertical movement
          ctx.drawImage(
            char2.image,
            char2.x,
            char2.y,
            char2.width,
            char2.height
          );
        }
        //char1.y += 0.5; // Adjust the speed as needed
        //char2.y += 0.5; // Adjust the speed as needed

        if (playerHealth <= 0) {
          gameOver();
          [
            "backgroundMusic",
            "song1",
            "song2",
            "song3",
            "song4",
            "song5",
            "song6",
            "song7",
          ].forEach((songId) => {
            let song = document.getElementById(songId);
            song.pause();
            song.currentTime = 0; // Reset the song to the beginning
          });
          displayGameOver();
          return;
        }

        // Collision detection and response for char1
        if (
          playerX < char1.x + char1.width &&
          playerX + playerWidth > char1.x &&
          playerY < char1.y + char1.height &&
          playerHeight + playerY > char1.y
        ) {
          // Apply the effect of char1
          currentBulletImage = altBulletImage; // Change bullet image
          setTimeout(() => {
            currentBulletImage = bulletImage; // Reset bullet image after 7 seconds
          }, 7000);

          // Move char1 off-screen
          char1.y = -100; // Position above the top of the canvas
          char1Cooldown = Date.now() + charCooldownTime;
        }

        // Collision detection and response for char2
        if (
          playerX < char2.x + char2.width &&
          playerX + playerWidth > char2.x &&
          playerY < char2.y + char2.height &&
          playerHeight + playerY > char2.y
        ) {
          // Apply the effect of char2
          let originalBulletSpeed = bulletSpeed;
          bulletSpeed /= 3; // Halve the bullet speed
          setTimeout(() => {
            bulletSpeed = originalBulletSpeed; // Restore original speed after 7 seconds
          }, 7000);

          // Move char2 off-screen
          char2.y = -100; // Position above the top of the canvas
          char2Cooldown = Date.now() + charCooldownTime;
        }

        enemies.forEach((enemy, enemyIndex) => {
          enemy.y += enemySpeed;
          enemy.x += enemy.horizontalSpeed;

          if (Math.random() < 0.0005) {
            // 10% chance every frame to change direction
            enemy.horizontalSpeed *= -1;
          }

          enemy.x += enemy.horizontalSpeed;

          if (
            playerX < enemy.x + enemyWidth &&
            playerX + playerWidth > enemy.x &&
            playerY < enemy.y + enemyHeight &&
            playerHeight + playerY > enemy.y
          ) {
            enemies.splice(enemyIndex, 1);
            playerHealth -= 30;
            document.getElementById("explosionSound").play(); // Play explosion sound
          }

          if (enemy.x > canvas.width - enemyWidth || enemy.x < 0) {
            enemy.horizontalSpeed *= -1;
          }

          if (enemy.y > canvas.height - enemyHeight) {
            playerHealth -= 10; // Decrease player's life by 10
            bombs.push({
              x: enemy.x,
              y: canvas.height - enemyHeight,
              timer: bombDisplayTime,
            });
            enemies.splice(enemyIndex, 1);
            document.getElementById("explosionSound").play(); // Play explosion sound
          }

          if (enemy.shouldBeRemoved) {
            console.log(
              "Removing enemy at index",
              index,
              "on level",
              currentLevel
            );
          }
        });

        powerUps.forEach((powerUp, index) => {
          powerUp.y += powerUpSpeed;
          if (powerUp.y > canvas.height) {
            powerUps.splice(index, 1);
          }

          if (
            playerX < powerUp.x + powerUpWidth &&
            playerX + playerWidth > powerUp.x &&
            playerY < powerUp.y + powerUpHeight &&
            playerHeight + playerY > powerUp.y
          ) {
            powerUps.splice(index, 1);
            isPowerUpActive = true;
            setTimeout(() => {
              isPowerUpActive = false;
            }, powerUpActiveTime);
            changeGameMusic();
            document.getElementById("powerUpSound").play(); // Play sound on power-up collection
          }
        });

        if (enemies.length === 0) {
          if (currentLevel < levels) {
            currentLevel++;
            GameAnalytics(
              "addProgressionEvent",
              "Start",
              currentLevel.toString()
            );
            spawnEnemies();
          } else {
            displayGameOver();
          }
        }

        bullets.forEach((bullet, bulletIndex) => {
          bullet.y -= bulletSpeed;

          if (bullet.y < 0) {
            bullets.splice(bulletIndex, 1);
          }

          enemies.forEach((enemy, enemyIndex) => {
            if (
              bullet.x < enemy.x + enemyWidth &&
              bullet.x + bulletWidth > enemy.x &&
              bullet.y < enemy.y + enemyHeight &&
              bullet.y + bulletHeight > enemy.y
            ) {
              enemies.splice(enemyIndex, 1);
              bullets.splice(bulletIndex, 1);
              score += 10;
              enemyKills += 1;

              if (Math.random() < 0.05) {
                powerUps.push({ x: enemy.x, y: enemy.y });
              }
            }
          });
        });

        bombs.forEach((bomb, index) => {
          if (bomb.timer > 0) {
            drawBomb(bomb.x, bomb.y);

            bomb.timer--;
          } else {
            bombs.splice(index, 1);
          }
        });

        characters.forEach((char, index) => {
          char.y += char.speed;
          if (char.y > canvas.height) {
            characters.splice(index, 1);
          }
        });
      }

      function changeGameMusic() {
        // Stop all songs
        let songs = ["backgroundMusic", "song1", "song2", "song3", "song4"];
        songs.forEach((songId) => document.getElementById(songId).pause());

        // Randomly pick a new song
        let randomSongId = songs[Math.floor(Math.random() * songs.length)];
        let newSong = document.getElementById(randomSongId);
        newSong.currentTime = 0;
        newSong.play();
      }

      function displayGameOver() {
        isGameOver = true;

        backgroundMusic.pause();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Set background to black
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Play Again button
        ctx.fillStyle = "#FFD700"; // Gold color for the button
        ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 40, 200, 40);
        ctx.fillStyle = "black";
        ctx.fillText(
          "Play Again",
          canvas.width / 2 - 60,
          canvas.height / 2 + 70
        );
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);

        playAgainButtonBounds = {
          x: canvas.width / 2 - 100,
          y: canvas.height / 2 + 40,
          width: 200,
          height: 40,
        };

        canvas.style.cursor = "default"; // Make the cursor visible

        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText(
          "Game Over!",
          canvas.width / 2 - 100,
          canvas.height / 2 - 20
        );
        ctx.font = "20px Arial";
        ctx.fillText(
          "Your score: " + score,
          canvas.width / 2 - 60,
          canvas.height / 2 + 20
        );

        // Draw Play Again button on canvas
        ctx.fillStyle = "#FFD700"; // Gold color for the button
        ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 40, 200, 40);
        ctx.fillStyle = "black";
        ctx.fillText(
          "Play Again",
          canvas.width / 2 - 60,
          canvas.height / 2 + 70
        );
      }

      function displayStageCompletion() {
        console.log("Displaying Stage Completion");

        ctx.save(); // Save the current state of the canvas

        ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; // Semi-transparent black overlay
        ctx.fillRect(0, 0, canvas.width, canvas.height); // Cover the entire canvas

        ctx.fillStyle = "white";
        ctx.font = "40px 'Press Start 2P', Arial";
        ctx.textAlign = "center";
        ctx.fillText("Stage Complete!", canvas.width / 2, canvas.height / 2);

        ctx.restore(); // Restore the canvas state to what it was before
      }

      function nextLevel() {
        if (currentLevel < levels) {
          clearInterval(gameInterval); // Stop the main game loop temporarily

          displayStageCompletion(); // Show stage completion message

          // Increase the delay for the next level
          setTimeout(() => {
            currentLevel++;
            GameAnalytics(
              "addProgressionEvent",
              "Start",
              currentLevel.toString()
            );
            resetLevel(); // Reset the level here
            spawnEnemies(); // Spawn new enemies for the next level
            requestAnimationFrame(gameLoop); // Add this line
          }, 7000); // 7-second pause between levels
        } else {
          displayGameOver();
        }
      }

      function resetLevel() {
        enemies = []; // Reset enemies
        bullets = []; // Reset bullets
        powerUps = []; // Reset power-ups
        targets = []; // Clear existing targets
        spawnTargets(); // Spawn new targets
        spawnEnemies(); // Spawn new enemies
        spawnCharacter(char1, 3000, 12000); // Spawn char1 at random intervals between 3 and 6 seconds
        spawnCharacter(char2, 3000, 8000);
      }

      // Call nextLevel() when all enemies are defeated
      if (enemies.length === 0) {
        nextLevel();
      }

      function resetGame() {
        // Reset game variables to initial state
        isGameOver = false;
        currentLevel = 1; // Reset level to 1
        score = 0;
        playerHealth = 100;
        enemyKills = 0;
        enemies = []; // Clear enemies
        bullets = []; // Clear bullets
        powerUps = []; // Clear power-ups
        bombs = []; // Clear bombs

        // Reset player position
        playerX = canvas.width / 2;
        playerY = canvas.height - 30;

        // Reset enemy properties
        enemySpeed = 0.35; // Reset to initial enemy speed
        enemyHorizontalSpeed = 1; // Reset to initial horizontal speed

        spawnEnemies(); // Spawn initial set of enemies
        spawnCharacter(char1, 3000, 4000); // Spawn char1 at random intervals between 3 and 6 seconds
        spawnCharacter(char2, 5000, 10000);

        requestAnimationFrame(gameLoop); // Add this line
        canvas.style.cursor = "none"; // Hide cursor
        document.getElementById("backgroundMusic").play(); // Restart background music

        var backgroundMusic = document.getElementById("backgroundMusic");
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0; // Reset music to the start
        backgroundMusic.play(); //
      }
      document.addEventListener("keydown", function (event) {
        if (event.keyCode === 32 && !isGameOver) {
          // Space bar for shooting
          if (!isGameOver) {
            shoot();
            event.preventDefault(); // Prevent default behavior of the space bar
          }
        }
      });
      canvas.addEventListener("keydown", function (event) {
        if (isGameOver) {
          // Check if the click is within the Play Again button area
          if (
            event.clientX >= canvas.width / 2 - 100 &&
            event.clientX <= canvas.width / 2 + 100 &&
            event.clientY >= canvas.height / 2 + 40 &&
            event.clientY <= canvas.height / 2 + 80
          ) {
            resetGame();
          }
        } else {
          shoot();
        }
      });

      canvas.addEventListener("click", function (event) {
        if (isGameOver) {
          // Only check for clicks if the game is over
          let rect = canvas.getBoundingClientRect();
          let x = event.clientX - rect.left;
          let y = event.clientY - rect.top;

          // Check if the click is inside the Play Again button area
          if (
            playAgainButtonBounds &&
            x >= playAgainButtonBounds.x &&
            x <= playAgainButtonBounds.x + playAgainButtonBounds.width &&
            y >= playAgainButtonBounds.y &&
            y <= playAgainButtonBounds.y + playAgainButtonBounds.height
          ) {
            resetGame();
          } else {
            shoot(); // Only call shoot if the game is active
          }
        }
      });

      canvas.addEventListener("mousemove", (event) => {
        playerX = event.clientX - canvas.offsetLeft - playerWidth / 2;
        playerY = event.clientY - canvas.offsetTop - playerHeight / 2;
        if (!isGameOver) {
          canvas.addEventListener("click", function (event) {
            let rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            let y = event.clientY - rect.top;

            // Check if the click is outside the Play Again button area
            if (
              !playAgainButtonBounds ||
              x < playAgainButtonBounds.x ||
              x > playAgainButtonBounds.x + playAgainButtonBounds.width ||
              y < playAgainButtonBounds.y ||
              y > playAgainButtonBounds.y + playAgainButtonBounds.height
            ) {
              shoot();
            }
          });
        }
      });

      function shoot() {
        if (
          !isGameOver &&
          (bulletFrequencyTimer <= 0 ||
            lastShotTime + shootingInterval <= Date.now())
        ) {
          bullets.push({
            x: playerX + playerWidth / 2 - bulletWidth / 2,
            y: playerY,
          });
          lastShotTime = Date.now(); // Track the last shot time
        }
      }

      loadTargetImages();

      requestAnimationFrame(gameLoop); // Add this line
    </script>
  </body>
</html>
